---
title: "Applied Statistic HW2"
author: "2020270026 王姿文、2020211316 周斯萤、2020211314 徐颢轩"
date: "2020/10/15"
output: html_document
---

```{r setup, include=FALSE, echo=F}
knitr::opts_chunk$set(echo = TRUE)
library(ggpubr)
library(ggplot2)
library(kableExtra)
options("scipen"=100, "digits"=4)
library(showtext)
font_files()
showtext_auto(enable = TRUE)
```

### Question 1 试基于以下几种思路对元件寿命参数$\frac{1}{\lambda}$进行估计，尽可能给出点估计的理论表达式。
#### 1.1 利用取值小于T的样本值占样本容量的比例
$P(X<T)=\int_{0}^{T}\lambda e^{-\lambda x}dx=1-e^{-\lambda T}$   
$\Rightarrow \frac{1}{\hat{\lambda}}=\frac{-T}{\log (1-p_{(x<y)})}$

#### 1.2 利用样本中所有取值小于T的部分的均值
$E(X|X<T)=\frac{1}{1-e^{-\lambda T}}\int_{0}^{T}\lambda xe^{-\lambda x}dx=\frac{1}{1-e^{-\lambda T}}\frac{1}{\lambda }\int_{0}^{\lambda T}\lambda xe^{-x}dx=\frac{1}{\lambda(1-e^{-\lambda T})}(-\lambda T e^{-\lambda T}+1-e^{-\lambda T})=\frac{1-(\lambda T+1)e^{-\lambda T}}{\lambda (1-e^{-\lambda T})}$
$\Rightarrow \frac{1-(\hat{\lambda} T+1)e^{-\hat{\lambda} T}}{\hat{\lambda} (1-e^{-hat{\lambda} T})}-m(x)_{(x<t)}=0$

#### 1.3 利用样本均值
$E[Y]=\frac{1-e^{-\lambda T}}{\lambda}$
$Let \frac{1}{\lambda}=\theta$    
$\Rightarrow \hat{\theta}^{-1}\overline {y}+e^{-\frac {t}{\theta}}-1=0$    

#### 1.4 利用极大似然估计
Likelihood fuction$=\frac{n!}{(n-r)!}\prod_{i=1}^{k}(\lambda e^{-\lambda y_{(i)}}(e^{- \lambda T})^{n-k})$   
Ignore constant,    
$\ln L=k \ln \lambda-\lambda \sum_{i=1}^{k}y_{(i)}-\lambda T(n-k)$    
$\frac {\partial \ln L}{\partial \lambda } = \frac {k}{\lambda}- \sum_{i=1}^{i=k}y_{(i)}-T(n-k)=0$    
$\Rightarrow \frac{1}{\hat\lambda}=\frac{\sum_{i=1}^{i=k}y_{(i)}+T(n-k)}{k}$   $=\frac{\sum_{i=1}^{i=k}y_{(i)}}{k}$
k为n个样本中小于T的样本个数


------------------------

### Question 2 设$\frac{1}{\lambda} = \frac{1}{1000}$,分别取T=500,800,1000,1200,1500，按照上述抽样规则模拟生成样本观测值，样本容量自己确定，可多尝试几种不同的样本容量，计算出问题1中四种估计方法的估计值；将每种估计方法重复模拟多次（可选取不同的次数），利用模拟结果比较各种估计方法的优劣，并且比较 的取值对估计效果的影响。
#### 2.1 利用取值小于T的样本值占样本容量的比例估计
#### i 比較T
下图为模拟次数(n)=1000、样本容量(m)=10000时，T分别为500,800,1000,1200,1500的图。
```{r echo=F, warning=FALSE, message=FALSE,fig.width = 18, fig.height=10}
f1 <- function(n,m,T){
  c11 <- numeric(n)
  for (i in 1:n){
  x1 <- rexp(m,rate = (1/1000))
  y1 <- numeric(m)
  for (j1 in 1:m){
    if (x1[j1] < T){
      y1[j1] <- 1
    }
    else{
      y1[j1] <- 0
    }
  }
  c11[i] <- -T/log(1-sum(y1)/m)
  }
  df <- data.frame(aesx=c(1:n),aesy=c11)
ggplot(df,aes(x=aesx,y=aesy)) +
  geom_point(col = 'skyblue',size = 2, alpha = 0.8) + 
  ggtitle(paste("取值小于T的比例估计 T为",T,"，样本容量为",m,"模拟次数为", n,
                sep='')) +
  xlab("N") + ylab("Estimate") + 
  theme(
    plot.title = element_text(size=14, face="bold", family = 'Songti'),
    axis.title.x = element_text(size=12),
    axis.title.y = element_text(size=12)
  )
}

ggarrange(f1(1000,10000,500),f1(1000,10000,800),f1(1000,10000,1000),f1(1000,10000,1200),f1(1000,10000,1500),ncol=2,nrow=3)
```

可以结合问题三，从无偏性、有效性和均方误差，以T不同的值來比较优劣，下表为无偏性、有效性和均方误差的结果。在期望值与实际值（1000）差不多的条件下，可以看出T越大，VAR及MSE越小，因此**T越大估计效果越好。**    
```{r echo=F, fig.height=10, fig.width=18, message=FALSE, warning=FALSE}
f1Q <- function(n,m,T){
  c11 <- numeric(n)
  for (i in 1:n){
    x1 <- rexp(m,rate = (1/1000))
    y1 <- numeric(m)
    for (j1 in 1:m){
      if (x1[j1] < T){
        y1[j1] <- 1
      }
      else{
        y1[j1] <- 0
      }
    }
    c11[i] <- -T/log(1-sum(y1)/m)
  }
  df <- data.frame(aesx=c(1:n),aesy=c11)
  
  Q3<-function(y){
    e<-(sum(y)/length(y))
    var<-(sum((y-e)^2)/length(y))
    mse<-(var+(e-1000)^2)
    x<-rep(0,3)
    x[1]<-e
    x[2]<-var
    x[3]<-mse
    return(x)
  }
  Q3(c11)
}

T1 <- f1Q(1000,10000,500);T2 <- f1Q(1000,10000,800);T3 <- f1Q(1000,10000,1000);
T4 <- f1Q(1000,10000,1200);T5 <- f1Q(1000,10000,1500)

table <- data.frame(模拟次数=c('1000','1000','1000','1000','1000'),
                        样本容量=c('10000','10000','10000','10000','10000'),
                    T=c('500','800','1000','1200','1500'),
                    Expectation=c(T1[1],T2[1],T3[1],T4[1],T5[1]),
                    Variation=c(T1[2],T2[2],T3[2],T4[2],T5[2]),
                    MSE=c(T1[3],T2[3],T3[3],T4[3],T5[3]))
                    
kbl(table) %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = F)
```

#### ii 比較模拟次数(n)
以下我们则实验在固定T=1500的条件下，样本容量(m)=10000不变，分别取模拟次数(n)=100,1000,10000。从下表可以看出在期望值与实际值（1000）差不多的条件下，模拟次数(n)越大，VAR及MSE不一定越小，因此**模拟次数(n)越大估计效果不一定越好。**
```{r echo=F, warning=FALSE, message=FALSE,fig.width = 18, fig.height=10}
f1 <- function(n,m,T){
  c11 <- numeric(n)
  for (i in 1:n){
  x1 <- rexp(m,rate = (1/1000))
  y1 <- numeric(m)
  for (j1 in 1:m){
    if (x1[j1] < T){
      y1[j1] <- 1
    }
    else{
      y1[j1] <- 0
    }
  }
  c11[i] <- -T/log(1-sum(y1)/m)
  }
  df <- data.frame(aesx=c(1:n),aesy=c11)
ggplot(df,aes(x=aesx,y=aesy)) +
  geom_point(col = 'skyblue',size = 2, alpha = 0.8) + 
  ggtitle(paste("取值小于T的比例估计 T为",T,"，样本容量为",m,"模拟次数为", n,
                sep='')) +
  xlab("N") + ylab("Estimate") + 
  theme(
    plot.title = element_text(size=14, face="bold", family = 'Songti'),
    axis.title.x = element_text(size=12),
    axis.title.y = element_text(size=12)
  )
}

ggarrange(f1(100,10000,1500),f1(1000,10000,1500),f1(10000,10000,1500),ncol=2,nrow=2)
```

```{r echo=F, fig.height=10, fig.width=18, message=FALSE, warning=FALSE}
f1Q <- function(n,m,T){
  c11 <- numeric(n)
  for (i in 1:n){
    x1 <- rexp(m,rate = (1/1000))
    y1 <- numeric(m)
    for (j1 in 1:m){
      if (x1[j1] < T){
        y1[j1] <- 1
      }
      else{
        y1[j1] <- 0
      }
    }
    c11[i] <- -T/log(1-sum(y1)/m)
  }
  df <- data.frame(aesx=c(1:n),aesy=c11)
  
  Q3<-function(y){
    e<-(sum(y)/length(y))
    var<-(sum((y-e)^2)/length(y))
    mse<-(var+(e-1000)^2)
    x<-rep(0,3)
    x[1]<-e
    x[2]<-var
    x[3]<-mse
    return(x)
  }
  Q3(c11)
}

T1 <- f1Q(100,10000,1500);T2 <- f1Q(1000,10000,1500);T3 <- f1Q(10000,10000,1500);

table <- data.frame(模拟次数=c('100','1000','10000'),
                        样本容量=c('10000','10000','10000'),
                    T=c('1500','1500','1500'),
                    Expectation=c(T1[1],T2[1],T3[1]),
                    Variation=c(T1[2],T2[2],T3[2]),
                    MSE=c(T1[3],T2[3],T3[3]))
                    
kbl(table) %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = F)
```

#### iii 比較样本容量(m)
以下我们则实验在固定T=1500的条件下，模拟次数(n)=10000不变，分别取样本容量(m)=100,1000,10000。从下表可以看出在期望值与实际值（1000）差不多的条件下，样本容量(m)越大，VAR及MSE越小，因此**样本容量(m)越大估计效果越好。**
```{r echo=F, warning=FALSE, message=FALSE,fig.width = 18, fig.height=10}
f1 <- function(n,m,T){
  c11 <- numeric(n)
  for (i in 1:n){
  x1 <- rexp(m,rate = (1/1000))
  y1 <- numeric(m)
  for (j1 in 1:m){
    if (x1[j1] < T){
      y1[j1] <- 1
    }
    else{
      y1[j1] <- 0
    }
  }
  c11[i] <- -T/log(1-sum(y1)/m)
  }
  df <- data.frame(aesx=c(1:n),aesy=c11)
ggplot(df,aes(x=aesx,y=aesy)) +
  geom_point(col = 'skyblue',size = 2, alpha = 0.8) + 
  ggtitle(paste("取值小于T的比例估计 T为",T,"，样本容量为",m,"模拟次数为", n,
                sep='')) +
  xlab("N") + ylab("Estimate") + 
  theme(
    plot.title = element_text(size=14, face="bold", family = 'Songti'),
    axis.title.x = element_text(size=12),
    axis.title.y = element_text(size=12)
  )
}

ggarrange(f1(10000,100,1500),f1(10000,1000,1500),f1(10000,10000,1500),ncol=2,nrow=2)
```

```{r echo=F, fig.height=10, fig.width=18, message=FALSE, warning=FALSE}
f1Q <- function(n,m,T){
  c11 <- numeric(n)
  for (i in 1:n){
    x1 <- rexp(m,rate = (1/1000))
    y1 <- numeric(m)
    for (j1 in 1:m){
      if (x1[j1] < T){
        y1[j1] <- 1
      }
      else{
        y1[j1] <- 0
      }
    }
    c11[i] <- -T/log(1-sum(y1)/m)
  }
  df <- data.frame(aesx=c(1:n),aesy=c11)
  
  Q3<-function(y){
    e<-(sum(y)/length(y))
    var<-(sum((y-e)^2)/length(y))
    mse<-(var+(e-1000)^2)
    x<-rep(0,3)
    x[1]<-e
    x[2]<-var
    x[3]<-mse
    return(x)
  }
  Q3(c11)
}

T1 <- f1Q(10000,100,1500);T2 <- f1Q(10000,1000,1500);T3 <- f1Q(10000,10000,1500);

table <- data.frame(模拟次数=c('10000','10000','10000'),
                        样本容量=c('100','1000','10000'),
                    T=c('1500','1500','1500'),
                    Expectation=c(T1[1],T2[1],T3[1]),
                    Variation=c(T1[2],T2[2],T3[2]),
                    MSE=c(T1[3],T2[3],T3[3]))
                    
kbl(table) %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = F)
```

综上所述，T、样本容量(m)都是越大越好，模拟次数(n)则不一定。

#### 2.2 利用样本中所有取值小于T的部分的均值
#### i 比較T
下图为模拟次数(n)=1000、样本容量(m)=10000时，T分别为500,800,1000,1200,1500的图。
```{r echo=F, warning=FALSE, message=FALSE,fig.width = 18, fig.height=10}
f2 <- function(n,m,T){
  c11 <- numeric(n)
  for (i in 1:n){
  x1 <- rexp(m,rate = (1/1000))
  y1 <- numeric(m)
  z1 <- numeric(m)
  for (j1 in 1:m){
    if (x1[j1] < T){
      y1[j1] <- x1[j1]
      z1[j1] <- 1
    }
    else{
      y1[j1] <- 0
      z1[j1] <- 0
    }
  }
  f1 <- function(l) ((1-(l*T+1)/exp(l*T))/(l*(1-exp(-l*T)))-sum(y1)/sum(z1))
  ans1 <- uniroot(f1,c(1,2000),extendInt="yes")
  c11[i] <- 1/ans1$root
}
  df <- data.frame(aesx=c(1:n),aesy=c11)
  ggplot(df,aes(x=aesx,y=aesy)) +
    geom_point(col = 'skyblue',size = 2, alpha = 0.8) + 
    ggtitle(paste("取值小于T的均值估计 T=",T,"，样本容量=",m,"模拟次数=", n,
                  sep='')) +
    xlab("N") + ylab("Estimate") + 
    theme(
      plot.title = element_text(size=14, face="bold", family = 'Songti'),
      axis.title.x = element_text(size=12),
      axis.title.y = element_text(size=12)
    )}
ggarrange(f2(1000,10000,500),f2(1000,10000,800),f2(1000,10000,1000),f2(1000,10000,1200),f2(1000,10000,1500),ncol=2,nrow=3)

```

可以结合问题三，从无偏性、有效性和均方误差，以T不同的值來比较优劣，下表为无偏性、有效性和均方误差的结果。在期望值与实际值（1000）差不多的条件下，可以看出T越大，VAR及MSE越小，因此**T越大估计效果越好。**   
```{r echo=F, fig.height=10, fig.width=18, message=FALSE, warning=FALSE}
f2Q <- function(n,m,T){
  c11 <- numeric(n)
  for (i in 1:n){
  x1 <- rexp(m,rate = (1/1000))
  y1 <- numeric(m)
  z1 <- numeric(m)
  for (j1 in 1:m){
    if (x1[j1] < T){
      y1[j1] <- x1[j1]
      z1[j1] <- 1
    }
    else{
      y1[j1] <- 0
      z1[j1] <- 0
    }
  }
  f1 <- function(l) ((1-(l*T+1)/exp(l*T))/(l*(1-exp(-l*T)))-sum(y1)/sum(z1))
  ans1 <- uniroot(f1,c(1,2000),extendInt="yes")
  c11[i] <- 1/ans1$root
}
  Q3<-function(y){
    e<-(sum(y)/length(y))
    var<-(sum((y-e)^2)/length(y))
    mse<-(var+(e-1000)^2)
    x<-rep(0,3)
    x[1]<-e
    x[2]<-var
    x[3]<-mse
    return(x)
  }
  Q3(c11)
 }


T1 <- f2Q(1000,10000,500);T2 <- f2Q(1000,10000,800);T3 <- f2Q(1000,10000,1000);
T4 <- f2Q(1000,10000,1200);T5 <- f2Q(1000,10000,1500)

table <- data.frame(模拟次数=c('1000','1000','1000','1000','1000'),
                        样本容量=c('10000','10000','10000','10000','10000'),
                    T=c('500','800','1000','1200','1500'),
                    Expectation=c(T1[1],T2[1],T3[1],T4[1],T5[1]),
                    Variation=c(T1[2],T2[2],T3[2],T4[2],T5[2]),
                    MSE=c(T1[3],T2[3],T3[3],T4[3],T5[3]))
                    
kbl(table) %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = F)
```

#### ii 比較模拟次数(n)
以下我们则实验在固定T=1500的条件下，样本容量(m)=10000不变，分别取模拟次数(n)=100,1000,10000。从下表可以看出在期望值与实际值（1000）差不多的条件下，模拟次数(n)越大，VAR及MSE不会越小，因此**模拟次数(n)越大估计效果不一定越好。**

```{r echo=F, warning=FALSE, message=FALSE,fig.width = 18, fig.height=10}
f2 <- function(n,m,T){
  c11 <- numeric(n)
  for (i in 1:n){
  x1 <- rexp(m,rate = (1/1000))
  y1 <- numeric(m)
  z1 <- numeric(m)
  for (j1 in 1:m){
    if (x1[j1] < T){
      y1[j1] <- x1[j1]
      z1[j1] <- 1
    }
    else{
      y1[j1] <- 0
      z1[j1] <- 0
    }
  }
  f1 <- function(l) ((1-(l*T+1)/exp(l*T))/(l*(1-exp(-l*T)))-sum(y1)/sum(z1))
  ans1 <- uniroot(f1,c(1,2000),extendInt="yes")
  c11[i] <- 1/ans1$root
}
  df <- data.frame(aesx=c(1:n),aesy=c11)
  ggplot(df,aes(x=aesx,y=aesy)) +
    geom_point(col = 'skyblue',size = 2, alpha = 0.8) + 
    ggtitle(paste("取值小于T的均值估计 T=",T,"，样本容量=",m,"模拟次数=", n,
                  sep='')) +
    xlab("N") + ylab("Estimate") + 
    theme(
      plot.title = element_text(size=14, face="bold", family = 'Songti'),
      axis.title.x = element_text(size=12),
      axis.title.y = element_text(size=12)
    )}
ggarrange(f2(100,10000,1500),f2(1000,10000,1500),f2(10000,10000,1500),ncol=2,nrow=2)
```

```{r echo=F, fig.height=10, fig.width=18, message=FALSE, warning=FALSE}
f2Q <- function(n,m,T){
  c11 <- numeric(n)
  for (i in 1:n){
  x1 <- rexp(m,rate = (1/1000))
  y1 <- numeric(m)
  z1 <- numeric(m)
  for (j1 in 1:m){
    if (x1[j1] < T){
      y1[j1] <- x1[j1]
      z1[j1] <- 1
    }
    else{
      y1[j1] <- 0
      z1[j1] <- 0
    }
  }
  f1 <- function(l) ((1-(l*T+1)/exp(l*T))/(l*(1-exp(-l*T)))-sum(y1)/sum(z1))
  ans1 <- uniroot(f1,c(1,2000),extendInt="yes")
  c11[i] <- 1/ans1$root
}
  Q3<-function(y){
    e<-(sum(y)/length(y))
    var<-(sum((y-e)^2)/length(y))
    mse<-(var+(e-1000)^2)
    x<-rep(0,3)
    x[1]<-e
    x[2]<-var
    x[3]<-mse
    return(x)
  }
  Q3(c11)
 }


T1 <- f2Q(100,10000,1500);T2 <- f2Q(1000,10000,1500);T3 <- f2Q(10000,10000,1500);

table <- data.frame(模拟次数=c('100','1000','10000'),
                        样本容量=c('10000','10000','10000'),
                    T=c('1500','1500','1500'),
                    Expectation=c(T1[1],T2[1],T3[1]),
                    Variation=c(T1[2],T2[2],T3[2]),
                    MSE=c(T1[3],T2[3],T3[3]))
                    
kbl(table) %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = F)
```


#### iii 比較样本容量(m)
以下我们则实验在固定T=1500的条件下，模拟次数(n)=10000不变，分别取样本容量(m)=100,1000,10000。从下表可以看出在期望值与实际值（1000）差不多的条件下，样本容量(m)越大，VAR及MSE越小，因此**样本容量(m)越大估计效果越好。**

```{r echo=F, warning=FALSE, message=FALSE,fig.width = 18, fig.height=10}
f2 <- function(n,m,T){
  c11 <- numeric(n)
  for (i in 1:n){
  x1 <- rexp(m,rate = (1/1000))
  y1 <- numeric(m)
  z1 <- numeric(m)
  for (j1 in 1:m){
    if (x1[j1] < T){
      y1[j1] <- x1[j1]
      z1[j1] <- 1
    }
    else{
      y1[j1] <- 0
      z1[j1] <- 0
    }
  }
  f1 <- function(l) ((1-(l*T+1)/exp(l*T))/(l*(1-exp(-l*T)))-sum(y1)/sum(z1))
  ans1 <- uniroot(f1,c(1,2000),extendInt="yes")
  c11[i] <- 1/ans1$root
}
  df <- data.frame(aesx=c(1:n),aesy=c11)
  ggplot(df,aes(x=aesx,y=aesy)) +
    geom_point(col = 'skyblue',size = 2, alpha = 0.8) + 
    ggtitle(paste("取值小于T的均值估计 T=",T,"，样本容量=",m,"模拟次数=", n,
                  sep='')) +
    xlab("N") + ylab("Estimate") + 
    theme(
      plot.title = element_text(size=14, face="bold", family = 'Songti'),
      axis.title.x = element_text(size=12),
      axis.title.y = element_text(size=12)
    )}
ggarrange(f2(10000,100,1500),f2(10000,1000,1500),f2(10000,10000,1500),ncol=2,nrow=2)
```

```{r echo=F, fig.height=10, fig.width=18, message=FALSE, warning=FALSE}
f2Q <- function(n,m,T){
  c11 <- numeric(n)
  for (i in 1:n){
  x1 <- rexp(m,rate = (1/1000))
  y1 <- numeric(m)
  z1 <- numeric(m)
  for (j1 in 1:m){
    if (x1[j1] < T){
      y1[j1] <- x1[j1]
      z1[j1] <- 1
    }
    else{
      y1[j1] <- 0
      z1[j1] <- 0
    }
  }
  f1 <- function(l) ((1-(l*T+1)/exp(l*T))/(l*(1-exp(-l*T)))-sum(y1)/sum(z1))
  ans1 <- uniroot(f1,c(1,2000),extendInt="yes")
  c11[i] <- 1/ans1$root
}
  Q3<-function(y){
    e<-(sum(y)/length(y))
    var<-(sum((y-e)^2)/length(y))
    mse<-(var+(e-1000)^2)
    x<-rep(0,3)
    x[1]<-e
    x[2]<-var
    x[3]<-mse
    return(x)
  }
  Q3(c11)
 }


T1 <- f2Q(10000,100,1500);T2 <- f2Q(10000,1000,1500);T3 <- f2Q(10000,10000,1500);

table <- data.frame(模拟次数=c('10000','10000','10000'),
                        样本容量=c('100','1000','10000'),
                    T=c('1500','1500','1500'),
                    Expectation=c(T1[1],T2[1],T3[1]),
                    Variation=c(T1[2],T2[2],T3[2]),
                    MSE=c(T1[3],T2[3],T3[3]))
                    
kbl(table) %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = F)
```

综上所述，T、样本容量(m)都是越大越好，模拟次数(n)则不一定。

#### 2.3 利用样本均值
#### i 比較T
下图为模拟次数(n)=1000、样本容量(m)=10000时，T分别为500,800,1000,1200,1500的图。
```{r echo=F, warning=FALSE, message=FALSE,fig.width = 18, fig.height=10}
f3 <- function(n,m,T){
  c11 <- numeric(n)
for (i in 1:n){
  x1 <- rexp(m,rate = (1/1000))
  y1 <- numeric(m)
  for (j1 in 1:m){
    if (x1[j1] < T){
      y1[j1] <- x1[j1]
    }
    else{
      y1[j1] <- T
    }
  }
  f1 <- function(l) (l^(-1)*(sum(y1)/m)+exp(-(T/l))-1)
  ans1 <- uniroot(f1,c(1,2000),extendInt="yes")
  c11[i] <- ans1$root
}
  df <- data.frame(aesx=c(1:n),aesy=c11)
  ggplot(df,aes(x=aesx,y=aesy)) +
    geom_point(col = 'skyblue',size = 2, alpha = 0.8) + 
    ggtitle(paste("样本均值估计 T=",T,"，样本容量=",m,"模拟次数=", n,
                  sep='')) +
    xlab("N") + ylab("Estimate") + 
    theme(
      plot.title = element_text(size=14, face="bold", family = 'Songti'),
      axis.title.x = element_text(size=12),
      axis.title.y = element_text(size=12)
    )  
}
ggarrange(f3(1000,10000,500),f3(1000,10000,800),f3(1000,10000,1000),f3(1000,10000,1200),f3(1000,10000,1500),ncol=2,nrow=3)

```

可以结合问题三，从无偏性、有效性和均方误差，以T不同的值來比较优劣，下表为无偏性、有效性和均方误差的结果。在期望值与实际值（1000）差不多的条件下，可以看出T越大，VAR及MSE越小，因此**T越大估计效果越好。**  
```{r echo=F, warning=FALSE, message=FALSE,fig.width = 18, fig.height=10}
f3Q <- function(n,m,T){
  c11 <- numeric(n)
for (i in 1:n){
  x1 <- rexp(m,rate = (1/1000))
  y1 <- numeric(m)
  for (j1 in 1:m){
    if (x1[j1] < T){
      y1[j1] <- x1[j1]
    }
    else{
      y1[j1] <- T
    }
  }
  f1 <- function(l) (l^(-1)*(sum(y1)/m)+exp(-(T/l))-1)
  ans1 <- uniroot(f1,c(1,2000),extendInt="yes")
  c11[i] <- ans1$root
}
  Q3<-function(y){
    e<-(sum(y)/length(y))
    var<-(sum((y-e)^2)/length(y))
    mse<-(var+(e-1000)^2)
    x<-rep(0,3)
    x[1]<-e
    x[2]<-var
    x[3]<-mse
    return(x)
  }
  Q3(c11)
}

T1 <- f3Q(1000,10000,500);T2 <- f3Q(1000,10000,800);T3 <- f3Q(1000,10000,1000);
T4 <- f3Q(1000,10000,1200);T5 <- f3Q(1000,10000,1500)

table <- data.frame(模拟次数=c('1000','1000','1000','1000','1000'),
                        样本容量=c('10000','10000','10000','10000','10000'),
                    T=c('500','800','1000','1200','1500'),
                    Expectation=c(T1[1],T2[1],T3[1],T4[1],T5[1]),
                    Variation=c(T1[2],T2[2],T3[2],T4[2],T5[2]),
                    MSE=c(T1[3],T2[3],T3[3],T4[3],T5[3]))
                    
kbl(table) %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = F)
```

#### ii 比較模拟次数(n)
以下我们则实验在固定T=1500的条件下，样本容量(m)=10000不变，分别取模拟次数(n)=100,1000,10000。从下表可以看出在期望值与实际值（1000）差不多的条件下，模拟次数(n)越大，VAR及MSE不一定越小，因此**模拟次数(n)越大估计效果不一定越好。**

```{r echo=F, warning=FALSE, message=FALSE,fig.width = 18, fig.height=10}
f3 <- function(n,m,T){
  c11 <- numeric(n)
for (i in 1:n){
  x1 <- rexp(m,rate = (1/1000))
  y1 <- numeric(m)
  for (j1 in 1:m){
    if (x1[j1] < T){
      y1[j1] <- x1[j1]
    }
    else{
      y1[j1] <- T
    }
  }
  f1 <- function(l) (l^(-1)*(sum(y1)/m)+exp(-(T/l))-1)
  ans1 <- uniroot(f1,c(1,2000),extendInt="yes")
  c11[i] <- ans1$root
}
  df <- data.frame(aesx=c(1:n),aesy=c11)
  ggplot(df,aes(x=aesx,y=aesy)) +
    geom_point(col = 'skyblue',size = 2, alpha = 0.8) + 
    ggtitle(paste("样本均值估计 T=",T,"，样本容量=",m,"模拟次数=", n,
                  sep='')) +
    xlab("N") + ylab("Estimate") + 
    theme(
      plot.title = element_text(size=14, face="bold", family = 'Songti'),
      axis.title.x = element_text(size=12),
      axis.title.y = element_text(size=12)
    )  
}
ggarrange(f3(100,10000,1500),f3(1000,10000,1500),f3(10000,10000,1500),ncol=2,nrow=2)

```

```{r echo=F, warning=FALSE, message=FALSE,fig.width = 18, fig.height=10}
f3Q <- function(n,m,T){
  c11 <- numeric(n)
for (i in 1:n){
  x1 <- rexp(m,rate = (1/1000))
  y1 <- numeric(m)
  for (j1 in 1:m){
    if (x1[j1] < T){
      y1[j1] <- x1[j1]
    }
    else{
      y1[j1] <- T
    }
  }
  f1 <- function(l) (l^(-1)*(sum(y1)/m)+exp(-(T/l))-1)
  ans1 <- uniroot(f1,c(1,2000),extendInt="yes")
  c11[i] <- ans1$root
}
  Q3<-function(y){
    e<-(sum(y)/length(y))
    var<-(sum((y-e)^2)/length(y))
    mse<-(var+(e-1000)^2)
    x<-rep(0,3)
    x[1]<-e
    x[2]<-var
    x[3]<-mse
    return(x)
  }
  Q3(c11)
}

T1 <- f3Q(100,10000,1500);T2 <- f3Q(1000,10000,1500);T3 <- f3Q(10000,10000,1500);

table <- data.frame(模拟次数=c('100','1000','10000'),
                        样本容量=c('10000','10000','10000'),
                    T=c('1500','1500','1500'),
                    Expectation=c(T1[1],T2[1],T3[1]),
                    Variation=c(T1[2],T2[2],T3[2]),
                    MSE=c(T1[3],T2[3],T3[3]))                  
kbl(table) %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = F)
```


#### iii 比較样本容量(m)
以下我们则实验在固定T=1500的条件下，模拟次数(n)=10000不变，分别取样本容量(m)=100,1000,10000。从下表可以看出在期望值与实际值（1000）差不多的条件下，样本容量(m)越大，VAR及MSE越小，因此**样本容量(m)越大估计效果越好。**

```{r echo=F, warning=FALSE, message=FALSE,fig.width = 18, fig.height=10}
f3 <- function(n,m,T){
  c11 <- numeric(n)
for (i in 1:n){
  x1 <- rexp(m,rate = (1/1000))
  y1 <- numeric(m)
  for (j1 in 1:m){
    if (x1[j1] < T){
      y1[j1] <- x1[j1]
    }
    else{
      y1[j1] <- T
    }
  }
  f1 <- function(l) (l^(-1)*(sum(y1)/m)+exp(-(T/l))-1)
  ans1 <- uniroot(f1,c(1,2000),extendInt="yes")
  c11[i] <- ans1$root
}
  df <- data.frame(aesx=c(1:n),aesy=c11)
  ggplot(df,aes(x=aesx,y=aesy)) +
    geom_point(col = 'skyblue',size = 2, alpha = 0.8) + 
    ggtitle(paste("样本均值估计 T=",T,"，样本容量=",m,"模拟次数=", n,
                  sep='')) +
    xlab("N") + ylab("Estimate") + 
    theme(
      plot.title = element_text(size=14, face="bold", family = 'Songti'),
      axis.title.x = element_text(size=12),
      axis.title.y = element_text(size=12)
    )  
}
ggarrange(f3(10000,100,1500),f3(10000,1000,1500),f3(10000,10000,1500),ncol=2,nrow=2)

```

```{r echo=F, warning=FALSE, message=FALSE,fig.width = 18, fig.height=10}
f3Q <- function(n,m,T){
  c11 <- numeric(n)
for (i in 1:n){
  x1 <- rexp(m,rate = (1/1000))
  y1 <- numeric(m)
  for (j1 in 1:m){
    if (x1[j1] < T){
      y1[j1] <- x1[j1]
    }
    else{
      y1[j1] <- T
    }
  }
  f1 <- function(l) (l^(-1)*(sum(y1)/m)+exp(-(T/l))-1)
  ans1 <- uniroot(f1,c(1,2000),extendInt="yes")
  c11[i] <- ans1$root
}
  Q3<-function(y){
    e<-(sum(y)/length(y))
    var<-(sum((y-e)^2)/length(y))
    mse<-(var+(e-1000)^2)
    x<-rep(0,3)
    x[1]<-e
    x[2]<-var
    x[3]<-mse
    return(x)
  }
  Q3(c11)
}

T1 <- f3Q(10000,100,1500);T2 <- f3Q(10000,1000,1500);T3 <- f3Q(10000,10000,1500);

table <- data.frame(模拟次数=c('10000','10000','10000'),
                        样本容量=c('100','1000','10000'),
                    T=c('1500','1500','1500'),
                    Expectation=c(T1[1],T2[1],T3[1]),
                    Variation=c(T1[2],T2[2],T3[2]),
                    MSE=c(T1[3],T2[3],T3[3]))                  
kbl(table) %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = F)
```

综上所述，T、样本容量(m)都是越大越好，模拟次数(n)则不一定。

#### 2.4 利用极大似然估计
#### i 比較T
下图为模拟次数(n)=1000、样本容量(m)=10000时，T分别为500,800,1000,1200,1500的图。
```{r echo=F, warning=FALSE, message=FALSE,fig.width = 18, fig.height=10}
f4<-function(n,m,T){
  data<-matrix(0,nrow=n,ncol=m)
  x1<-rep(0,n)
  lamda1<-rep(0,n)
  for(i in 1:n){ 
    for(j in 1:m){
      data[i,j]<-min(T,rexp(1,(1/1000)))
      if(data[i,j]<T){
        x1[i]=x1[i]+1
      }
      else{
        x1[i]=x1[i]+0
      }
    }
    lamda1[i]<-sum(data[i,])/x1[i] 
  }
  df <- data.frame(aesx=c(1:n),aesy=lamda1)
  ggplot(df,aes(x=aesx,y=aesy)) +
    geom_point(col = 'skyblue',size = 2, alpha = 0.8) + 
    ggtitle(paste("极大似然估计 T为",T,"，样本容量为",m,"模拟次数为", n,
                  sep='')) +
    xlab("N") + ylab("Estimate") + 
    theme(
      plot.title = element_text(size=14, face="bold", family = 'Songti'),
      axis.title.x = element_text(size=12),
      axis.title.y = element_text(size=12)
    )
}
ggarrange(f4(1000,10000,500),f4(1000,10000,800),f4(1000,10000,1000),f4(1000,10000,1200),f4(1000,10000,1500),ncol=2,nrow=3)
```

可以结合问题三，从无偏性、有效性和均方误差，以T不同的值來比较优劣，下表为无偏性、有效性和均方误差的结果。在期望值与实际值（1000）差不多的条件下，可以看出T越大，VAR及MSE越小，因此**T越大估计效果越好。**    

```{r echo=F, warning=FALSE, message=FALSE,fig.width = 18, fig.height=10}
f4Q<-function(n,m,T){
  data<-matrix(0,nrow=n,ncol=m)
  x1<-rep(0,n)
  lamda1<-rep(0,n)
  for(i in 1:n){ 
    for(j in 1:m){
      data[i,j]<-min(T,rexp(1,(1/1000)))
      if(data[i,j]<T){
        x1[i]=x1[i]+1
      }
      else{
        x1[i]=x1[i]+0
      }
    }
    lamda1[i]<-sum(data[i,])/x1[i] 
  }
 Q3<-function(y){
    e<-(sum(y)/length(y))
    var<-(sum((y-e)^2)/length(y))
    mse<-(var+(e-1000)^2)
    x<-rep(0,3)
    x[1]<-e
    x[2]<-var
    x[3]<-mse
    return(x)
  }
  Q3(lamda1)
}

T1 <- f4Q(1000,10000,500);T2 <- f4Q(1000,10000,800);T3 <- f4Q(1000,10000,1000);
T4 <- f4Q(1000,10000,1200);T5 <- f4Q(1000,10000,1500)

table <- data.frame(模拟次数=c('1000','1000','1000','1000','1000'),
                        样本容量=c('10000','10000','10000','10000','10000'),
                    T=c('500','800','1000','1200','1500'),
                    Expectation=c(T1[1],T2[1],T3[1],T4[1],T5[1]),
                    Variation=c(T1[2],T2[2],T3[2],T4[2],T5[2]),
                    MSE=c(T1[3],T2[3],T3[3],T4[3],T5[3]))
                    
kbl(table) %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = F) 
```

#### ii 比較模拟次数(n)
以下我们则实验在固定T=1500的条件下，样本容量(m)=10000不变，分别取模拟次数(n)=100,1000,10000。从下表可以看出在期望值与实际值（1000）差不多的条件下，模拟次数(n)越大，VAR及MSE不一定越小，因此**模拟次数(n)越大估计效果不一定越好。**

```{r echo=F, warning=FALSE, message=FALSE,fig.width = 18, fig.height=10}
f4<-function(n,m,T){
  data<-matrix(0,nrow=n,ncol=m)
  x1<-rep(0,n)
  lamda1<-rep(0,n)
  for(i in 1:n){ 
    for(j in 1:m){
      data[i,j]<-min(T,rexp(1,(1/1000)))
      if(data[i,j]<T){
        x1[i]=x1[i]+1
      }
      else{
        x1[i]=x1[i]+0
      }
    }
    lamda1[i]<-sum(data[i,])/x1[i] 
  }
  df <- data.frame(aesx=c(1:n),aesy=lamda1)
  ggplot(df,aes(x=aesx,y=aesy)) +
    geom_point(col = 'skyblue',size = 2, alpha = 0.8) + 
    ggtitle(paste("极大似然估计 T为",T,"，样本容量为",m,"模拟次数为", n,
                  sep='')) +
    xlab("N") + ylab("Estimate") + 
    theme(
      plot.title = element_text(size=14, face="bold", family = 'Songti'),
      axis.title.x = element_text(size=12),
      axis.title.y = element_text(size=12)
    )
}
ggarrange(f4(100,10000,1500),f4(1000,10000,1500),f4(10000,10000,1500),ncol=2,nrow=2)
```

```{r echo=F, warning=FALSE, message=FALSE,fig.width = 18, fig.height=10}
f4Q<-function(n,m,T){
  data<-matrix(0,nrow=n,ncol=m)
  x1<-rep(0,n)
  lamda1<-rep(0,n)
  for(i in 1:n){ 
    for(j in 1:m){
      data[i,j]<-min(T,rexp(1,(1/1000)))
      if(data[i,j]<T){
        x1[i]=x1[i]+1
      }
      else{
        x1[i]=x1[i]+0
      }
    }
    lamda1[i]<-sum(data[i,])/x1[i] 
  }
 Q3<-function(y){
    e<-(sum(y)/length(y))
    var<-(sum((y-e)^2)/length(y))
    mse<-(var+(e-1000)^2)
    x<-rep(0,3)
    x[1]<-e
    x[2]<-var
    x[3]<-mse
    return(x)
  }
  Q3(lamda1)
}

T1 <- f4Q(100,10000,1500);T2 <- f4Q(1000,10000,1500);T3 <- f4Q(10000,10000,1500);

table <- data.frame(模拟次数=c('100','1000','10000'),
                        样本容量=c('10000','10000','10000'),
                    T=c('1500','1500','1500'),
                    Expectation=c(T1[1],T2[1],T3[1]),
                    Variation=c(T1[2],T2[2],T3[2]),
                    MSE=c(T1[3],T2[3],T3[3]))
                    
kbl(table) %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = F) 
```

#### iii 比較样本容量(m)
以下我们则实验在固定T=1500的条件下，模拟次数(n)=10000不变，分别取样本容量(m)=100,1000,10000。从下表可以看出在期望值与实际值（1000）差不多的条件下，样本容量(m)越大，VAR及MSE越小，因此**样本容量(m)越大估计效果越好。**

```{r echo=F, warning=FALSE, message=FALSE,fig.width = 18, fig.height=10}
f4<-function(n,m,T){
  data<-matrix(0,nrow=n,ncol=m)
  x1<-rep(0,n)
  lamda1<-rep(0,n)
  for(i in 1:n){ 
    for(j in 1:m){
      data[i,j]<-min(T,rexp(1,(1/1000)))
      if(data[i,j]<T){
        x1[i]=x1[i]+1
      }
      else{
        x1[i]=x1[i]+0
      }
    }
    lamda1[i]<-sum(data[i,])/x1[i] 
  }
  df <- data.frame(aesx=c(1:n),aesy=lamda1)
  ggplot(df,aes(x=aesx,y=aesy)) +
    geom_point(col = 'skyblue',size = 2, alpha = 0.8) + 
    ggtitle(paste("极大似然估计 T为",T,"，样本容量为",m,"模拟次数为", n,
                  sep='')) +
    xlab("N") + ylab("Estimate") + 
    theme(
      plot.title = element_text(size=14, face="bold", family = 'Songti'),
      axis.title.x = element_text(size=12),
      axis.title.y = element_text(size=12)
    )
}
ggarrange(f4(10000,100,1500),f4(10000,1000,1500),f4(10000,10000,1500),ncol=2,nrow=2)
```

```{r echo=F, warning=FALSE, message=FALSE,fig.width = 18, fig.height=10}
f4Q<-function(n,m,T){
  data<-matrix(0,nrow=n,ncol=m)
  x1<-rep(0,n)
  lamda1<-rep(0,n)
  for(i in 1:n){ 
    for(j in 1:m){
      data[i,j]<-min(T,rexp(1,(1/1000)))
      if(data[i,j]<T){
        x1[i]=x1[i]+1
      }
      else{
        x1[i]=x1[i]+0
      }
    }
    lamda1[i]<-sum(data[i,])/x1[i] 
  }
 Q3<-function(y){
    e<-(sum(y)/length(y))
    var<-(sum((y-e)^2)/length(y))
    mse<-(var+(e-1000)^2)
    x<-rep(0,3)
    x[1]<-e
    x[2]<-var
    x[3]<-mse
    return(x)
  }
  Q3(lamda1)
}

T1 <- f4Q(10000,100,1500);T2 <- f4Q(10000,1000,1500);T3 <- f4Q(10000,10000,1500);

table <- data.frame(模拟次数=c('10000','10000','10000'),
                        样本容量=c('100','1000','10000'),
                    T=c('1500','1500','1500'),
                    Expectation=c(T1[1],T2[1],T3[1]),
                    Variation=c(T1[2],T2[2],T3[2]),
                    MSE=c(T1[3],T2[3],T3[3]))
                    
kbl(table) %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = F) 
```

综上所述，T、样本容量(m)都是越大越好，模拟次数(n)则不一定。

-------------------------

### Question 3 问题1中四种估计方法中哪些能够进行无偏性、有效性和均方误差的理论分析，并给出相应的分析；用数值模拟的方法给出四种估计量的无偏性、有效性和均方误差的分析和判断。

固定模拟次数(n)=1000、样本容量(m)=10000、T=1000，分别将1.1命为方法一；1.2命危方法二；1.3命为方法三；1.4命为方法四。下表比较四种估计方法的评估比较。下表可以根据无偏性、有效性和均方误差来评估，Expectation越接近1000（真实值）越好；VAR越小越好；MSE越小越好，无偏性代表是否准确，有效性代表预测是否精确，而均方误差则可同时表示偏差及有效的特质，因为$MSE=Var(\hat{\theta})+Bias(\hat{\theta},\theta)^2; Bias(\hat{\theta},\theta)=E(\hat{\theta}-\theta)$。根据下表和理论，方法二最不好而其他方法的差异没到很大。
```{r echo=F, fig.height=10, fig.width=18, message=FALSE, warning=FALSE}
f1Q <- function(n,m,T){
  c11 <- numeric(n)
  for (i in 1:n){
    x1 <- rexp(m,rate = (1/1000))
    y1 <- numeric(m)
    for (j1 in 1:m){
      if (x1[j1] < T){
        y1[j1] <- 1
      }
      else{
        y1[j1] <- 0
      }
    }
    c11[i] <- -T/log(1-sum(y1)/m)
  }
  df <- data.frame(aesx=c(1:n),aesy=c11)
  
  Q3<-function(y){
    e<-(sum(y)/length(y))
    var<-(sum((y-e)^2)/length(y))
    mse<-(var+(e-1000)^2)
    x<-rep(0,3)
    x[1]<-e
    x[2]<-var
    x[3]<-mse
    return(x)
  }
  Q3(c11)
}

f2Q <- function(n,m,T){
  c11 <- numeric(n)
  for (i in 1:n){
  x1 <- rexp(m,rate = (1/1000))
  y1 <- numeric(m)
  z1 <- numeric(m)
  for (j1 in 1:m){
    if (x1[j1] < T){
      y1[j1] <- x1[j1]
      z1[j1] <- 1
    }
    else{
      y1[j1] <- 0
      z1[j1] <- 0
    }
  }
  f1 <- function(l) ((1-(l*T+1)/exp(l*T))/(l*(1-exp(-l*T)))-sum(y1)/sum(z1))
  ans1 <- uniroot(f1,c(1,2000),extendInt="yes")
  c11[i] <- 1/ans1$root
}
  Q3<-function(y){
    e<-(sum(y)/length(y))
    var<-(sum((y-e)^2)/length(y))
    mse<-(var+(e-1000)^2)
    x<-rep(0,3)
    x[1]<-e
    x[2]<-var
    x[3]<-mse
    return(x)
  }
  Q3(c11)
 }

f3Q <- function(n,m,T){
  c11 <- numeric(n)
for (i in 1:n){
  x1 <- rexp(m,rate = (1/1000))
  y1 <- numeric(m)
  for (j1 in 1:m){
    if (x1[j1] < T){
      y1[j1] <- x1[j1]
    }
    else{
      y1[j1] <- T
    }
  }
  f1 <- function(l) (l^(-1)*(sum(y1)/m)+exp(-(T/l))-1)
  ans1 <- uniroot(f1,c(1,2000),extendInt="yes")
  c11[i] <- ans1$root
}
  Q3<-function(y){
    e<-(sum(y)/length(y))
    var<-(sum((y-e)^2)/length(y))
    mse<-(var+(e-1000)^2)
    x<-rep(0,3)
    x[1]<-e
    x[2]<-var
    x[3]<-mse
    return(x)
  }
  Q3(c11)
}

f4Q<-function(n,m,T){
  data<-matrix(0,nrow=n,ncol=m)
  x1<-rep(0,n)
  lamda1<-rep(0,n)
  for(i in 1:n){ 
    for(j in 1:m){
      data[i,j]<-min(T,rexp(1,(1/1000)))
      if(data[i,j]<T){
        x1[i]=x1[i]+1
      }
      else{
        x1[i]=x1[i]+0
      }
    }
    lamda1[i]<-sum(data[i,])/x1[i] 
  }
 Q3<-function(y){
    e<-(sum(y)/length(y))
    var<-(sum((y-e)^2)/length(y))
    mse<-(var+(e-1000)^2)
    x<-rep(0,3)
    x[1]<-e
    x[2]<-var
    x[3]<-mse
    return(x)
  }
  Q3(lamda1)
}

T1 <- f1Q(1000,10000,1000);T2 <- f2Q(1000,10000,1000);T3 <- f3Q(1000,10000,1000);
T4 <- f4Q(1000,10000,1000)

table <- data.frame(估计方法=c('方法一','方法二','方法三','方法四'),
                    Expectation=c(T1[1],T2[1],T3[1],T4[1]),
                    Variation=c(T1[2],T2[2],T3[2],T4[2]),
                    MSE=c(T1[3],T2[3],T3[3],T4[3]))
                    
kbl(table) %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = F)
```


-------------------------

### Question 4 仍然取$\frac{1}{\lambda} = \frac{1}{1000}$模拟生成样本值，因为实际抽样过程中可能并不知道寿命平均值的大致范围，所以难以给出合适的T的取值，可以分别考虑在30%、50%、70%（或其他比例）的样品失效时，停止试验。利用这样的抽样原则构造估计参数$\frac{1}{\lambda}$的方法，停止时间的规则如何确定比较合理，给出你的理由。

我们分别将取每个样本的百分之三十、百分之五十、百分之七十的样本分位数作为T的取值。在題三，我们得到在四种方法中，极大似然估计所得到的结果较好，因此用极大似然估计用于估计\frac{1}{\lambda}。   
根据结果发现，当所取分位数比例从百分之三十增加到百分之五十时，所得结果的期望基本维持在1000不变，但是方差和均方误差均有较大幅度下降。分析是因为当T取值增加时，我们得到的样本信息更多，且多得到的样本信息对估计参数有效。因此，在不考虑成本及其它因素的情况下，T应取值越大越好。但是由于当T取值过大时，在实际操作时，会造成较大成本。在同等样本量的情况下，T应在成本允许的范围内越大越好。在样本量较大的情况下，由于样本量的增加会使得方差和均方误差变小，可以考虑适当缩减T的取值。

```{r echo=F, warning=FALSE, message=FALSE,fig.width = 18, fig.height=10}
Q4<-function(n,m,a){
  data<-matrix(0,nrow=n,ncol=m)
  T<-rep(0,n)
  lamda1<-rep(0,n)
  for(i in 1:n){
    data[i,]<-rexp(m,(1/1000))
    data[i,]<-sort(data[i,])
    T[i]<-data[i,(a*m)]
    data[i,(a*m+1):m]<-T[i] 
    lamda1[i]<-sum(data[i,])/(a*m) 
  }
  df <- data.frame(aesx=c(1:n),aesy=lamda1)
  ggplot(df,aes(x=aesx,y=aesy)) +
    geom_point(col = 'skyblue',size = 2, alpha = 0.8) + 
    ggtitle(paste("极大似然估计T=",round(T,2),"，样本容量=",m,"模拟次数=", n,
                  sep='')) +
    xlab("N") + ylab("Estimate") + 
    theme(
      plot.title = element_text(size=14, face="bold", family = 'Songti'),
      axis.title.x = element_text(size=12),
      axis.title.y = element_text(size=12)
    )
}

ggarrange(Q4(1000,10000,(3/10)),Q4(1000,10000,(5/10)),Q4(1000,10000,(7/10)),ncol=2,nrow=2)

```

```{r echo=F, warning=FALSE, message=FALSE,fig.width = 18, fig.height=10}
Q4t<-function(n,m,a){
  data<-matrix(0,nrow=n,ncol=m)
  T<-rep(0,n)
  lamda1<-rep(0,n)
  for(i in 1:n){
    data[i,]<-rexp(m,(1/1000))
    data[i,]<-sort(data[i,])
    T[i]<-data[i,(a*m)]
    data[i,(a*m+1):m]<-T[i] 
    lamda1[i]<-sum(data[i,])/(a*m) 
  }
  e<-(sum(lamda1)/length(lamda1))
  var<-(sum((lamda1-e)^2)/length(lamda1))
  mse<-(var+(e-1000)^2)
  x<-rep(0,3)
  x[1]<-e
  x[2]<-var
  x[3]<-mse
  return(x)
}
T1 <- Q4t(1000,10000,(3/10))
T2 <- Q4t(1000,10000,(5/10))
T3 <- Q4t(1000,10000,(7/10))
T4 <- Q4t(1000,1000,(3/10))
T5 <- Q4t(1000,1000,(5/10))
T6 <- Q4t(1000,1000,(7/10))

table <- data.frame(T=c('30%','50%','70%','30%','50%','70%'),
                    样本容量=c('10000','10000','10000','1000','1000','1000'),
                        Expectation=c(T1[1],T2[1],T3[1],T4[1],T5[1],T6[1]),
                        Variation=c(T1[2],T2[2],T3[2],T4[2],T5[2],T6[2]),
                        MSE=c(T1[3],T2[3],T3[3],T4[3],T5[3],T6[3]))
kbl(table) %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = F)
```
------------------------

### Question 5 是否能给出更多对参数$\frac{1}{\lambda}$进行估计的办法，并进行模拟和分析。

使用截尾矩估计法来估计参数。   
$x_1,x_2,…,x_n$ 是相互独立且同分布的随机变量，其分布为 $G \frac{(x-\mu)}{\sigma}$，在 $(n,T)$ 方案下得到的观测值是 $(y_1, \delta_1),…,(y_n,\delta_1)$ ，这里的 $\delta_i$ 可以理解为被记录的标识变量，如被记录则为1，没有被记录则为0，其中，$y_i=min(x_i,T), \delta_i=I_{(x \leq T)}$，在此提出一种矩估计方法：   
令 $G^{-1}(u)=inf(x:G(x) \geq u),(0<u<1)$ ，即反函数。   
$h(p)=pG^{-1}(u)- \int_{0}^{p}G^{-1}(u)du$   
$\delta=I_{(x \leq T)}$   
$a_G=inf(x:G(x)>0), b_G=sup(x:G(x)<1)$   
$p=P(x \leq T)$   
定理:设 $0<p<1$，且 $G(x)$是$a_G,b_G$上的增函数，$Y=min(x,T)$，则有 $E[\delta(T-Y)]= \sigma h(p)$   
则 $\hat{\sigma}=\frac{1}{h(p)}E[\delta(T-Y)]$   
用 $\hat{p}= \frac {1}{n} \sum_{i=1}^{n} \delta_{i}(T-y_{i})$   
又 $\mu=T-\sigma G^{-1}(p)$，用$\hat{\mu}=T- \hat{\sigma}G^{-1}(\hat{p})$。   

在此题中，m代表截止Ｔ失效的产品个数，n为样本量， $x_{i}$ 服從 $Exp(\frac{1}{\lambda}=1000) $ ，因此 $\frac{1}{\hat{{\lambda}}}= \frac{1}{n(ln\frac{1}{1-{\frac{m}{n}}}-\frac{m}{n})}[mT-\sum_{i=1}^{m}x_{(i)}]$。   

#### i 比較T
下图为模拟次数(n)=1000、样本容量(m)=10000时，T分别为500,800,1000,1200,1500的图。
```{r echo=F, warning=FALSE, message=FALSE,fig.width = 18, fig.height=10}
f5<-function(n,m,T){
  data<-matrix(0,nrow=n,ncol=m)
  x1<-rep(0,n)
  lamda1<-rep(0,n)
  for(i in 1:n){ 
    for(j in 1:m){
      data[i,j]<-min(T,rexp(1,(1/1000)))
      if(data[i,j]<T){
        x1[i]=x1[i]+1
      }
      else{
        x1[i]=x1[i]+0
      }
    }
    lamda1[i]<-(m*T-sum(data[i,]))/(m*(log(1/(1-(x1[i]/m)))-(x1[i]/m)))
  }
  df <- data.frame(aesx=c(1:n),aesy=lamda1)
  ggplot(df,aes(x=aesx,y=aesy)) +
    geom_point(col = 'skyblue',size = 2, alpha = 0.8) + 
    ggtitle(paste("截尾矩估计 T为",T,"，样本容量为",m,"模拟次数为", n,
                  sep='')) +
    xlab("N") + ylab("Estimate") + 
    theme(
      plot.title = element_text(size=14, face="bold", family = 'Songti'),
      axis.title.x = element_text(size=12),
      axis.title.y = element_text(size=12)
    )
}
ggarrange(f5(1000,10000,500),f5(1000,10000,800),f5(1000,10000,1000),f5(1000,10000,1200),f5(1000,10000,1500),ncol=2,nrow=3)

```

可以结合问题三，从无偏性、有效性和均方误差，以T不同的值來比较优劣，下表为无偏性、有效性和均方误差的结果。在期望值与实际值（1000）差不多的条件下，可以看出T越大，VAR及MSE不一定越小，因此**T越大估计效果不一定越好。**    
```{r echo=F, fig.height=10, fig.width=18, message=FALSE, warning=FALSE}
f5Q <- function(n,m,T){
  data<-matrix(0,nrow=n,ncol=m)
  x1<-rep(0,n)
  lamda1<-rep(0,n)
  for(i in 1:n){ 
    for(j in 1:m){
      data[i,j]<-min(T,rexp(1,(1/1000)))
      if(data[i,j]<T){
        x1[i]=x1[i]+1
      }
      else{
        x1[i]=x1[i]+0
      }
    }
    lamda1[i]<-(m*T-sum(data[i,]))/(m*(log(1/(1-(x1[i]/m)))-(x1[i]/m)))
  }
  df <- data.frame(aesx=c(1:n),aesy=lamda1)
  Q3<-function(y){
    e<-(sum(y)/length(y))
    var<-(sum((y-e)^2)/length(y))
    mse<-(var+(e-1000)^2)
    x<-rep(0,3)
    x[1]<-e
    x[2]<-var
    x[3]<-mse
    return(x)
  }
  Q3(lamda1)
}

T1 <- f5Q(1000,10000,500);T2 <- f5Q(1000,10000,800);T3 <- f5Q(1000,10000,1000);
T4 <- f5Q(1000,10000,1200);T5 <- f5Q(1000,10000,1500)

table <- data.frame(模拟次数=c('1000','1000','1000','1000','1000'),
                        样本容量=c('10000','10000','10000','10000','10000'),
                    T=c('500','800','1000','1200','1500'),
                    Expectation=c(T1[1],T2[1],T3[1],T4[1],T5[1]),
                    Variation=c(T1[2],T2[2],T3[2],T4[2],T5[2]),
                    MSE=c(T1[3],T2[3],T3[3],T4[3],T5[3]))
                    
kbl(table) %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = F)
```

#### ii 比較模拟次数(n)
以下我们则实验在固定T=1500的条件下，样本容量(m)=10000不变，分别取模拟次数(n)=100,1000,10000。从下表可以看出在期望值与实际值（1000）差不多的条件下，模拟次数(n)越大，VAR及MSE不会越小，因此**模拟次数(n)越大估计效果不一定越好。**
```{r echo=F, warning=FALSE, message=FALSE,fig.width = 18, fig.height=10}
f5<-function(n,m,T){
  data<-matrix(0,nrow=n,ncol=m)
  x1<-rep(0,n)
  lamda1<-rep(0,n)
  for(i in 1:n){ 
    for(j in 1:m){
      data[i,j]<-min(T,rexp(1,(1/1000)))
      if(data[i,j]<T){
        x1[i]=x1[i]+1
      }
      else{
        x1[i]=x1[i]+0
      }
    }
    lamda1[i]<-(m*T-sum(data[i,]))/(m*(log(1/(1-(x1[i]/m)))-(x1[i]/m)))
  }
  df <- data.frame(aesx=c(1:n),aesy=lamda1)
  ggplot(df,aes(x=aesx,y=aesy)) +
    geom_point(col = 'skyblue',size = 2, alpha = 0.8) + 
    ggtitle(paste("截尾矩估计 T为",T,"，样本容量为",m,"模拟次数为", n,
                  sep='')) +
    xlab("N") + ylab("Estimate") + 
    theme(
      plot.title = element_text(size=14, face="bold", family = 'Songti'),
      axis.title.x = element_text(size=12),
      axis.title.y = element_text(size=12)
    )
}
ggarrange(f5(100,10000,1500),f5(1000,10000,1500),f5(10000,10000,1500),ncol=2,nrow=2)

```

```{r echo=F, fig.height=10, fig.width=18, message=FALSE, warning=FALSE}
f5Q <- function(n,m,T){
  data<-matrix(0,nrow=n,ncol=m)
  x1<-rep(0,n)
  lamda1<-rep(0,n)
  for(i in 1:n){ 
    for(j in 1:m){
      data[i,j]<-min(T,rexp(1,(1/1000)))
      if(data[i,j]<T){
        x1[i]=x1[i]+1
      }
      else{
        x1[i]=x1[i]+0
      }
    }
    lamda1[i]<-(m*T-sum(data[i,]))/(m*(log(1/(1-(x1[i]/m)))-(x1[i]/m)))
  }
  df <- data.frame(aesx=c(1:n),aesy=lamda1)
  Q3<-function(y){
    e<-(sum(y)/length(y))
    var<-(sum((y-e)^2)/length(y))
    mse<-(var+(e-1000)^2)
    x<-rep(0,3)
    x[1]<-e
    x[2]<-var
    x[3]<-mse
    return(x)
  }
  Q3(lamda1)
}

T1 <- f5Q(100,10000,1500);T2 <- f5Q(1000,10000,1500);T3 <- f5Q(10000,10000,1500);

table <- data.frame(模拟次数=c('100','1000','10000'),
                        样本容量=c('10000','10000','10000'),
                    T=c('1500','1500','1500'),
                    Expectation=c(T1[1],T2[1],T3[1]),
                    Variation=c(T1[2],T2[2],T3[2]),
                    MSE=c(T1[3],T2[3],T3[3]))
                    
kbl(table) %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = F)
```

#### iii 比較样本容量(m)
以下我们则实验在固定T=1500的条件下，模拟次数(n)=10000不变，分别取样本容量(m)=100,1000,10000。从下表可以看出在期望值与实际值（1000）差不多的条件下，样本容量(m)越大，VAR及MSE越小，因此**样本容量(m)越大估计效果越好。**
```{r echo=F, warning=FALSE, message=FALSE,fig.width = 18, fig.height=10}
f5<-function(n,m,T){
  data<-matrix(0,nrow=n,ncol=m)
  x1<-rep(0,n)
  lamda1<-rep(0,n)
  for(i in 1:n){ 
    for(j in 1:m){
      data[i,j]<-min(T,rexp(1,(1/1000)))
      if(data[i,j]<T){
        x1[i]=x1[i]+1
      }
      else{
        x1[i]=x1[i]+0
      }
    }
    lamda1[i]<-(m*T-sum(data[i,]))/(m*(log(1/(1-(x1[i]/m)))-(x1[i]/m)))
  }
  df <- data.frame(aesx=c(1:n),aesy=lamda1)
  ggplot(df,aes(x=aesx,y=aesy)) +
    geom_point(col = 'skyblue',size = 2, alpha = 0.8) + 
    ggtitle(paste("截尾矩估计 T为",T,"，样本容量为",m,"模拟次数为", n,
                  sep='')) +
    xlab("N") + ylab("Estimate") + 
    theme(
      plot.title = element_text(size=14, face="bold", family = 'Songti'),
      axis.title.x = element_text(size=12),
      axis.title.y = element_text(size=12)
    )
}
ggarrange(f5(10000,100,1500),f5(10000,1000,1500),f5(10000,10000,1500),ncol=2,nrow=2)

```

```{r echo=F, fig.height=10, fig.width=18, message=FALSE, warning=FALSE}
f5Q <- function(n,m,T){
  data<-matrix(0,nrow=n,ncol=m)
  x1<-rep(0,n)
  lamda1<-rep(0,n)
  for(i in 1:n){ 
    for(j in 1:m){
      data[i,j]<-min(T,rexp(1,(1/1000)))
      if(data[i,j]<T){
        x1[i]=x1[i]+1
      }
      else{
        x1[i]=x1[i]+0
      }
    }
    lamda1[i]<-(m*T-sum(data[i,]))/(m*(log(1/(1-(x1[i]/m)))-(x1[i]/m)))
  }
  df <- data.frame(aesx=c(1:n),aesy=lamda1)
  Q3<-function(y){
    e<-(sum(y)/length(y))
    var<-(sum((y-e)^2)/length(y))
    mse<-(var+(e-1000)^2)
    x<-rep(0,3)
    x[1]<-e
    x[2]<-var
    x[3]<-mse
    return(x)
  }
  Q3(lamda1)
}

T1 <- f5Q(10000,100,1500);T2 <- f5Q(10000,1000,1500);T3 <- f5Q(10000,10000,1500);

table <- data.frame(模拟次数=c('10000','10000','10000'),
                        样本容量=c('100','1000','10000'),
                    T=c('1500','1500','1500'),
                    Expectation=c(T1[1],T2[1],T3[1]),
                    Variation=c(T1[2],T2[2],T3[2]),
                    MSE=c(T1[3],T2[3],T3[3]))
                    
kbl(table) %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = F)
```

综上所述，T、样本容量(m)都是越大越好，模拟次数(n)则不一定。
